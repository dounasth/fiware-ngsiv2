<?php
/**
 * EntitiesApi
 * PHP version 5
 *
 * @category Class
 * @package  Dounasth\Ngsiv2
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * FIWARE-NGSI v2 Specification
 *
 * TODO: Add a description
 *
 * OpenAPI spec version: 1.0
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.31
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Dounasth\Ngsiv2\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Dounasth\Ngsiv2\ApiException;
use Dounasth\Ngsiv2\Configuration;
use Dounasth\Ngsiv2\HeaderSelector;
use Dounasth\Ngsiv2\ObjectSerializer;

/**
 * EntitiesApi Class Doc Comment
 *
 * @category Class
 * @package  Dounasth\Ngsiv2
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class EntitiesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createEntity
     *
     * Create Entity
     *
     * @param  string $content_type  (required)
     * @param  \Dounasth\Ngsiv2\Model\CreateEntityRequest $body  (required)
     * @param  string $options Options dictionary (optional)
     *
     * @throws \Dounasth\Ngsiv2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createEntity($content_type, $body, $options = null)
    {
        $this->createEntityWithHttpInfo($content_type, $body, $options);
    }

    /**
     * Operation createEntityWithHttpInfo
     *
     * Create Entity
     *
     * @param  string $content_type  (required)
     * @param  \Dounasth\Ngsiv2\Model\CreateEntityRequest $body  (required)
     * @param  string $options Options dictionary (optional)
     *
     * @throws \Dounasth\Ngsiv2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createEntityWithHttpInfo($content_type, $body, $options = null)
    {
        $returnType = '';
        $request = $this->createEntityRequest($content_type, $body, $options);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation createEntityAsync
     *
     * Create Entity
     *
     * @param  string $content_type  (required)
     * @param  \Dounasth\Ngsiv2\Model\CreateEntityRequest $body  (required)
     * @param  string $options Options dictionary (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEntityAsync($content_type, $body, $options = null)
    {
        return $this->createEntityAsyncWithHttpInfo($content_type, $body, $options)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createEntityAsyncWithHttpInfo
     *
     * Create Entity
     *
     * @param  string $content_type  (required)
     * @param  \Dounasth\Ngsiv2\Model\CreateEntityRequest $body  (required)
     * @param  string $options Options dictionary (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEntityAsyncWithHttpInfo($content_type, $body, $options = null)
    {
        $returnType = '';
        $request = $this->createEntityRequest($content_type, $body, $options);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createEntity'
     *
     * @param  string $content_type  (required)
     * @param  \Dounasth\Ngsiv2\Model\CreateEntityRequest $body  (required)
     * @param  string $options Options dictionary (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createEntityRequest($content_type, $body, $options = null)
    {
        // verify the required parameter 'content_type' is set
        if ($content_type === null || (is_array($content_type) && count($content_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content_type when calling createEntity'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createEntity'
            );
        }

        $resourcePath = '/v2/entities';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($options !== null) {
            $queryParams['options'] = ObjectSerializer::toQueryValue($options);
        }
        // header params
        if ($content_type !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($content_type);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listEntities
     *
     * List Entities
     *
     * @param  string $id A comma-separated list of elements. Retrieve entities whose ID matches one of the elements in the list. Incompatible with &#x60;idPattern&#x60;. (optional)
     * @param  string $type comma-separated list of elements. Retrieve entities whose type matches one of the elements in the list. Incompatible with &#x60;typePattern&#x60;. (optional)
     * @param  string $id_pattern A correctly formated regular expression. Retrieve entities whose ID matches the regular expression. Incompatible with &#x60;id&#x60;. (optional)
     * @param  string $type_pattern A correctly formated regular expression. Retrieve entities whose type matches the regular expression. Incompatible with &#x60;type&#x60;. (optional)
     * @param  string $q A query expression, composed of a list of statements separated by &#x60;;&#x60;, i.e., q&#x3D;statement1;statement2;statement3. See [Simple Query Language specification](#simple_query_language). (optional)
     * @param  string $mq A query expression for attribute metadata, composed of a list of statements separated by &#x60;;&#x60;, i.e., mq&#x3D;statement1;statement2;statement3. See [Simple Query Language specification](#simple_query_language). (optional)
     * @param  string $georel Spatial relationship between matching entities and a reference shape. See [Geographical Queries](#geographical_queries). (optional)
     * @param  string $geometry Geografical area to which the query is restricted. See [Geographical Queries](#geographical_queries). (optional)
     * @param  string $coords List of latitude-longitude pairs of coordinates separated by &#39;;&#39;. See [Geographical Queries](#geographical_queries). (optional)
     * @param  double $limit Limits the number of entities to be retrieved (optional)
     * @param  double $offset Establishes the offset from where entities are retrieved (optional)
     * @param  string $attrs Comma-separated list of attribute names whose data are to be included in the response. The attributes are retrieved in the order specified by this parameter. If this parameter is not included, the attributes are retrieved in arbitrary order. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)
     * @param  string $metadata A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)
     * @param  string $order_by Criteria for ordering results. See \&quot;Ordering Results\&quot; section for details. (optional)
     * @param  string $options Options dictionary (optional)
     *
     * @throws \Dounasth\Ngsiv2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Dounasth\Ngsiv2\Model\ListEntitiesResponse[]
     */
    public function listEntities($id = null, $type = null, $id_pattern = null, $type_pattern = null, $q = null, $mq = null, $georel = null, $geometry = null, $coords = null, $limit = null, $offset = null, $attrs = null, $metadata = null, $order_by = null, $options = null)
    {
        list($response) = $this->listEntitiesWithHttpInfo($id, $type, $id_pattern, $type_pattern, $q, $mq, $georel, $geometry, $coords, $limit, $offset, $attrs, $metadata, $order_by, $options);
        return $response;
    }

    /**
     * Operation listEntitiesWithHttpInfo
     *
     * List Entities
     *
     * @param  string $id A comma-separated list of elements. Retrieve entities whose ID matches one of the elements in the list. Incompatible with &#x60;idPattern&#x60;. (optional)
     * @param  string $type comma-separated list of elements. Retrieve entities whose type matches one of the elements in the list. Incompatible with &#x60;typePattern&#x60;. (optional)
     * @param  string $id_pattern A correctly formated regular expression. Retrieve entities whose ID matches the regular expression. Incompatible with &#x60;id&#x60;. (optional)
     * @param  string $type_pattern A correctly formated regular expression. Retrieve entities whose type matches the regular expression. Incompatible with &#x60;type&#x60;. (optional)
     * @param  string $q A query expression, composed of a list of statements separated by &#x60;;&#x60;, i.e., q&#x3D;statement1;statement2;statement3. See [Simple Query Language specification](#simple_query_language). (optional)
     * @param  string $mq A query expression for attribute metadata, composed of a list of statements separated by &#x60;;&#x60;, i.e., mq&#x3D;statement1;statement2;statement3. See [Simple Query Language specification](#simple_query_language). (optional)
     * @param  string $georel Spatial relationship between matching entities and a reference shape. See [Geographical Queries](#geographical_queries). (optional)
     * @param  string $geometry Geografical area to which the query is restricted. See [Geographical Queries](#geographical_queries). (optional)
     * @param  string $coords List of latitude-longitude pairs of coordinates separated by &#39;;&#39;. See [Geographical Queries](#geographical_queries). (optional)
     * @param  double $limit Limits the number of entities to be retrieved (optional)
     * @param  double $offset Establishes the offset from where entities are retrieved (optional)
     * @param  string $attrs Comma-separated list of attribute names whose data are to be included in the response. The attributes are retrieved in the order specified by this parameter. If this parameter is not included, the attributes are retrieved in arbitrary order. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)
     * @param  string $metadata A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)
     * @param  string $order_by Criteria for ordering results. See \&quot;Ordering Results\&quot; section for details. (optional)
     * @param  string $options Options dictionary (optional)
     *
     * @throws \Dounasth\Ngsiv2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Dounasth\Ngsiv2\Model\ListEntitiesResponse[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listEntitiesWithHttpInfo($id = null, $type = null, $id_pattern = null, $type_pattern = null, $q = null, $mq = null, $georel = null, $geometry = null, $coords = null, $limit = null, $offset = null, $attrs = null, $metadata = null, $order_by = null, $options = null)
    {
        $returnType = '\Dounasth\Ngsiv2\Model\ListEntitiesResponse[]';
        $request = $this->listEntitiesRequest($id, $type, $id_pattern, $type_pattern, $q, $mq, $georel, $geometry, $coords, $limit, $offset, $attrs, $metadata, $order_by, $options);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Dounasth\Ngsiv2\Model\ListEntitiesResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listEntitiesAsync
     *
     * List Entities
     *
     * @param  string $id A comma-separated list of elements. Retrieve entities whose ID matches one of the elements in the list. Incompatible with &#x60;idPattern&#x60;. (optional)
     * @param  string $type comma-separated list of elements. Retrieve entities whose type matches one of the elements in the list. Incompatible with &#x60;typePattern&#x60;. (optional)
     * @param  string $id_pattern A correctly formated regular expression. Retrieve entities whose ID matches the regular expression. Incompatible with &#x60;id&#x60;. (optional)
     * @param  string $type_pattern A correctly formated regular expression. Retrieve entities whose type matches the regular expression. Incompatible with &#x60;type&#x60;. (optional)
     * @param  string $q A query expression, composed of a list of statements separated by &#x60;;&#x60;, i.e., q&#x3D;statement1;statement2;statement3. See [Simple Query Language specification](#simple_query_language). (optional)
     * @param  string $mq A query expression for attribute metadata, composed of a list of statements separated by &#x60;;&#x60;, i.e., mq&#x3D;statement1;statement2;statement3. See [Simple Query Language specification](#simple_query_language). (optional)
     * @param  string $georel Spatial relationship between matching entities and a reference shape. See [Geographical Queries](#geographical_queries). (optional)
     * @param  string $geometry Geografical area to which the query is restricted. See [Geographical Queries](#geographical_queries). (optional)
     * @param  string $coords List of latitude-longitude pairs of coordinates separated by &#39;;&#39;. See [Geographical Queries](#geographical_queries). (optional)
     * @param  double $limit Limits the number of entities to be retrieved (optional)
     * @param  double $offset Establishes the offset from where entities are retrieved (optional)
     * @param  string $attrs Comma-separated list of attribute names whose data are to be included in the response. The attributes are retrieved in the order specified by this parameter. If this parameter is not included, the attributes are retrieved in arbitrary order. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)
     * @param  string $metadata A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)
     * @param  string $order_by Criteria for ordering results. See \&quot;Ordering Results\&quot; section for details. (optional)
     * @param  string $options Options dictionary (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEntitiesAsync($id = null, $type = null, $id_pattern = null, $type_pattern = null, $q = null, $mq = null, $georel = null, $geometry = null, $coords = null, $limit = null, $offset = null, $attrs = null, $metadata = null, $order_by = null, $options = null)
    {
        return $this->listEntitiesAsyncWithHttpInfo($id, $type, $id_pattern, $type_pattern, $q, $mq, $georel, $geometry, $coords, $limit, $offset, $attrs, $metadata, $order_by, $options)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listEntitiesAsyncWithHttpInfo
     *
     * List Entities
     *
     * @param  string $id A comma-separated list of elements. Retrieve entities whose ID matches one of the elements in the list. Incompatible with &#x60;idPattern&#x60;. (optional)
     * @param  string $type comma-separated list of elements. Retrieve entities whose type matches one of the elements in the list. Incompatible with &#x60;typePattern&#x60;. (optional)
     * @param  string $id_pattern A correctly formated regular expression. Retrieve entities whose ID matches the regular expression. Incompatible with &#x60;id&#x60;. (optional)
     * @param  string $type_pattern A correctly formated regular expression. Retrieve entities whose type matches the regular expression. Incompatible with &#x60;type&#x60;. (optional)
     * @param  string $q A query expression, composed of a list of statements separated by &#x60;;&#x60;, i.e., q&#x3D;statement1;statement2;statement3. See [Simple Query Language specification](#simple_query_language). (optional)
     * @param  string $mq A query expression for attribute metadata, composed of a list of statements separated by &#x60;;&#x60;, i.e., mq&#x3D;statement1;statement2;statement3. See [Simple Query Language specification](#simple_query_language). (optional)
     * @param  string $georel Spatial relationship between matching entities and a reference shape. See [Geographical Queries](#geographical_queries). (optional)
     * @param  string $geometry Geografical area to which the query is restricted. See [Geographical Queries](#geographical_queries). (optional)
     * @param  string $coords List of latitude-longitude pairs of coordinates separated by &#39;;&#39;. See [Geographical Queries](#geographical_queries). (optional)
     * @param  double $limit Limits the number of entities to be retrieved (optional)
     * @param  double $offset Establishes the offset from where entities are retrieved (optional)
     * @param  string $attrs Comma-separated list of attribute names whose data are to be included in the response. The attributes are retrieved in the order specified by this parameter. If this parameter is not included, the attributes are retrieved in arbitrary order. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)
     * @param  string $metadata A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)
     * @param  string $order_by Criteria for ordering results. See \&quot;Ordering Results\&quot; section for details. (optional)
     * @param  string $options Options dictionary (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listEntitiesAsyncWithHttpInfo($id = null, $type = null, $id_pattern = null, $type_pattern = null, $q = null, $mq = null, $georel = null, $geometry = null, $coords = null, $limit = null, $offset = null, $attrs = null, $metadata = null, $order_by = null, $options = null)
    {
        $returnType = '\Dounasth\Ngsiv2\Model\ListEntitiesResponse[]';
        $request = $this->listEntitiesRequest($id, $type, $id_pattern, $type_pattern, $q, $mq, $georel, $geometry, $coords, $limit, $offset, $attrs, $metadata, $order_by, $options);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listEntities'
     *
     * @param  string $id A comma-separated list of elements. Retrieve entities whose ID matches one of the elements in the list. Incompatible with &#x60;idPattern&#x60;. (optional)
     * @param  string $type comma-separated list of elements. Retrieve entities whose type matches one of the elements in the list. Incompatible with &#x60;typePattern&#x60;. (optional)
     * @param  string $id_pattern A correctly formated regular expression. Retrieve entities whose ID matches the regular expression. Incompatible with &#x60;id&#x60;. (optional)
     * @param  string $type_pattern A correctly formated regular expression. Retrieve entities whose type matches the regular expression. Incompatible with &#x60;type&#x60;. (optional)
     * @param  string $q A query expression, composed of a list of statements separated by &#x60;;&#x60;, i.e., q&#x3D;statement1;statement2;statement3. See [Simple Query Language specification](#simple_query_language). (optional)
     * @param  string $mq A query expression for attribute metadata, composed of a list of statements separated by &#x60;;&#x60;, i.e., mq&#x3D;statement1;statement2;statement3. See [Simple Query Language specification](#simple_query_language). (optional)
     * @param  string $georel Spatial relationship between matching entities and a reference shape. See [Geographical Queries](#geographical_queries). (optional)
     * @param  string $geometry Geografical area to which the query is restricted. See [Geographical Queries](#geographical_queries). (optional)
     * @param  string $coords List of latitude-longitude pairs of coordinates separated by &#39;;&#39;. See [Geographical Queries](#geographical_queries). (optional)
     * @param  double $limit Limits the number of entities to be retrieved (optional)
     * @param  double $offset Establishes the offset from where entities are retrieved (optional)
     * @param  string $attrs Comma-separated list of attribute names whose data are to be included in the response. The attributes are retrieved in the order specified by this parameter. If this parameter is not included, the attributes are retrieved in arbitrary order. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)
     * @param  string $metadata A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)
     * @param  string $order_by Criteria for ordering results. See \&quot;Ordering Results\&quot; section for details. (optional)
     * @param  string $options Options dictionary (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listEntitiesRequest($id = null, $type = null, $id_pattern = null, $type_pattern = null, $q = null, $mq = null, $georel = null, $geometry = null, $coords = null, $limit = null, $offset = null, $attrs = null, $metadata = null, $order_by = null, $options = null)
    {

        $resourcePath = '/v2/entities';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id !== null) {
            $queryParams['id'] = ObjectSerializer::toQueryValue($id);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($id_pattern !== null) {
            $queryParams['idPattern'] = ObjectSerializer::toQueryValue($id_pattern);
        }
        // query params
        if ($type_pattern !== null) {
            $queryParams['typePattern'] = ObjectSerializer::toQueryValue($type_pattern);
        }
        // query params
        if ($q !== null) {
            $queryParams['q'] = ObjectSerializer::toQueryValue($q);
        }
        // query params
        if ($mq !== null) {
            $queryParams['mq'] = ObjectSerializer::toQueryValue($mq);
        }
        // query params
        if ($georel !== null) {
            $queryParams['georel'] = ObjectSerializer::toQueryValue($georel);
        }
        // query params
        if ($geometry !== null) {
            $queryParams['geometry'] = ObjectSerializer::toQueryValue($geometry);
        }
        // query params
        if ($coords !== null) {
            $queryParams['coords'] = ObjectSerializer::toQueryValue($coords);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset);
        }
        // query params
        if ($attrs !== null) {
            $queryParams['attrs'] = ObjectSerializer::toQueryValue($attrs);
        }
        // query params
        if ($metadata !== null) {
            $queryParams['metadata'] = ObjectSerializer::toQueryValue($metadata);
        }
        // query params
        if ($order_by !== null) {
            $queryParams['orderBy'] = ObjectSerializer::toQueryValue($order_by);
        }
        // query params
        if ($options !== null) {
            $queryParams['options'] = ObjectSerializer::toQueryValue($options);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
//            $headers,
//            $httpBody
        );
    }

    /**
     * Operation removeEntity
     *
     * Remove Entity
     *
     * @param  string $entity_id Id of the entity to be deleted (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     *
     * @throws \Dounasth\Ngsiv2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function removeEntity($entity_id, $type = null)
    {
        $this->removeEntityWithHttpInfo($entity_id, $type);
    }

    /**
     * Operation removeEntityWithHttpInfo
     *
     * Remove Entity
     *
     * @param  string $entity_id Id of the entity to be deleted (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     *
     * @throws \Dounasth\Ngsiv2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function removeEntityWithHttpInfo($entity_id, $type = null)
    {
        $returnType = '';
        $request = $this->removeEntityRequest($entity_id, $type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation removeEntityAsync
     *
     * Remove Entity
     *
     * @param  string $entity_id Id of the entity to be deleted (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeEntityAsync($entity_id, $type = null)
    {
        return $this->removeEntityAsyncWithHttpInfo($entity_id, $type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation removeEntityAsyncWithHttpInfo
     *
     * Remove Entity
     *
     * @param  string $entity_id Id of the entity to be deleted (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function removeEntityAsyncWithHttpInfo($entity_id, $type = null)
    {
        $returnType = '';
        $request = $this->removeEntityRequest($entity_id, $type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'removeEntity'
     *
     * @param  string $entity_id Id of the entity to be deleted (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function removeEntityRequest($entity_id, $type = null)
    {
        // verify the required parameter 'entity_id' is set
        if ($entity_id === null || (is_array($entity_id) && count($entity_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entity_id when calling removeEntity'
            );
        }

        $resourcePath = '/v2/entities/{entityId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }

        // path params
        if ($entity_id !== null) {
            $resourcePath = str_replace(
                '{' . 'entityId' . '}',
                ObjectSerializer::toPathValue($entity_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation replaceAllEntityAttributes
     *
     * Replace all entity attributes
     *
     * @param  string $entity_id Id of the entity in question. (required)
     * @param  string $content_type  (required)
     * @param  \Dounasth\Ngsiv2\Model\ReplaceAllEntityAttributesRequest $body  (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     * @param  string $options Operations options (optional)
     *
     * @throws \Dounasth\Ngsiv2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function replaceAllEntityAttributes($entity_id, $content_type, $body, $type = null, $options = null)
    {
        $this->replaceAllEntityAttributesWithHttpInfo($entity_id, $content_type, $body, $type, $options);
    }

    /**
     * Operation replaceAllEntityAttributesWithHttpInfo
     *
     * Replace all entity attributes
     *
     * @param  string $entity_id Id of the entity in question. (required)
     * @param  string $content_type  (required)
     * @param  \Dounasth\Ngsiv2\Model\ReplaceAllEntityAttributesRequest $body  (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     * @param  string $options Operations options (optional)
     *
     * @throws \Dounasth\Ngsiv2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function replaceAllEntityAttributesWithHttpInfo($entity_id, $content_type, $body, $type = null, $options = null)
    {
        $returnType = '';
        $request = $this->replaceAllEntityAttributesRequest($entity_id, $content_type, $body, $type, $options);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation replaceAllEntityAttributesAsync
     *
     * Replace all entity attributes
     *
     * @param  string $entity_id Id of the entity in question. (required)
     * @param  string $content_type  (required)
     * @param  \Dounasth\Ngsiv2\Model\ReplaceAllEntityAttributesRequest $body  (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     * @param  string $options Operations options (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceAllEntityAttributesAsync($entity_id, $content_type, $body, $type = null, $options = null)
    {
        return $this->replaceAllEntityAttributesAsyncWithHttpInfo($entity_id, $content_type, $body, $type, $options)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation replaceAllEntityAttributesAsyncWithHttpInfo
     *
     * Replace all entity attributes
     *
     * @param  string $entity_id Id of the entity in question. (required)
     * @param  string $content_type  (required)
     * @param  \Dounasth\Ngsiv2\Model\ReplaceAllEntityAttributesRequest $body  (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     * @param  string $options Operations options (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function replaceAllEntityAttributesAsyncWithHttpInfo($entity_id, $content_type, $body, $type = null, $options = null)
    {
        $returnType = '';
        $request = $this->replaceAllEntityAttributesRequest($entity_id, $content_type, $body, $type, $options);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'replaceAllEntityAttributes'
     *
     * @param  string $entity_id Id of the entity in question. (required)
     * @param  string $content_type  (required)
     * @param  \Dounasth\Ngsiv2\Model\ReplaceAllEntityAttributesRequest $body  (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     * @param  string $options Operations options (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function replaceAllEntityAttributesRequest($entity_id, $content_type, $body, $type = null, $options = null)
    {
        // verify the required parameter 'entity_id' is set
        if ($entity_id === null || (is_array($entity_id) && count($entity_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entity_id when calling replaceAllEntityAttributes'
            );
        }
        // verify the required parameter 'content_type' is set
        if ($content_type === null || (is_array($content_type) && count($content_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content_type when calling replaceAllEntityAttributes'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling replaceAllEntityAttributes'
            );
        }

        $resourcePath = '/v2/entities/{entityId}/attrs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($options !== null) {
            $queryParams['options'] = ObjectSerializer::toQueryValue($options);
        }
        // header params
        if ($content_type !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($content_type);
        }

        // path params
        if ($entity_id !== null) {
            $resourcePath = str_replace(
                '{' . 'entityId' . '}',
                ObjectSerializer::toPathValue($entity_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation retrieveEntity
     *
     * Retrieve Entity
     *
     * @param  string $entity_id Id of the entity to be retrieved (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     * @param  string $attrs Comma-separated list of attribute names whose data must be included in the response. The attributes are retrieved in the order specified by this parameter. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. If this parameter is not included, the attributes are retrieved in arbitrary order, and all the attributes of the entity are included in the response. (optional)
     * @param  string $metadata A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)
     * @param  string $options Options dictionary (optional)
     *
     * @throws \Dounasth\Ngsiv2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Dounasth\Ngsiv2\Model\RetrieveEntityResponse
     */
    public function retrieveEntity($entity_id, $type = null, $attrs = null, $metadata = null, $options = null)
    {
        list($response) = $this->retrieveEntityWithHttpInfo($entity_id, $type, $attrs, $metadata, $options);
        return $response;
    }

    /**
     * Operation retrieveEntityWithHttpInfo
     *
     * Retrieve Entity
     *
     * @param  string $entity_id Id of the entity to be retrieved (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     * @param  string $attrs Comma-separated list of attribute names whose data must be included in the response. The attributes are retrieved in the order specified by this parameter. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. If this parameter is not included, the attributes are retrieved in arbitrary order, and all the attributes of the entity are included in the response. (optional)
     * @param  string $metadata A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)
     * @param  string $options Options dictionary (optional)
     *
     * @throws \Dounasth\Ngsiv2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Dounasth\Ngsiv2\Model\RetrieveEntityResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function retrieveEntityWithHttpInfo($entity_id, $type = null, $attrs = null, $metadata = null, $options = null)
    {
        $returnType = '\Dounasth\Ngsiv2\Model\RetrieveEntityResponse';
        $request = $this->retrieveEntityRequest($entity_id, $type, $attrs, $metadata, $options);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Dounasth\Ngsiv2\Model\RetrieveEntityResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation retrieveEntityAsync
     *
     * Retrieve Entity
     *
     * @param  string $entity_id Id of the entity to be retrieved (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     * @param  string $attrs Comma-separated list of attribute names whose data must be included in the response. The attributes are retrieved in the order specified by this parameter. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. If this parameter is not included, the attributes are retrieved in arbitrary order, and all the attributes of the entity are included in the response. (optional)
     * @param  string $metadata A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)
     * @param  string $options Options dictionary (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retrieveEntityAsync($entity_id, $type = null, $attrs = null, $metadata = null, $options = null)
    {
        return $this->retrieveEntityAsyncWithHttpInfo($entity_id, $type, $attrs, $metadata, $options)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation retrieveEntityAsyncWithHttpInfo
     *
     * Retrieve Entity
     *
     * @param  string $entity_id Id of the entity to be retrieved (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     * @param  string $attrs Comma-separated list of attribute names whose data must be included in the response. The attributes are retrieved in the order specified by this parameter. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. If this parameter is not included, the attributes are retrieved in arbitrary order, and all the attributes of the entity are included in the response. (optional)
     * @param  string $metadata A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)
     * @param  string $options Options dictionary (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retrieveEntityAsyncWithHttpInfo($entity_id, $type = null, $attrs = null, $metadata = null, $options = null)
    {
        $returnType = '\Dounasth\Ngsiv2\Model\RetrieveEntityResponse';
        $request = $this->retrieveEntityRequest($entity_id, $type, $attrs, $metadata, $options);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'retrieveEntity'
     *
     * @param  string $entity_id Id of the entity to be retrieved (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     * @param  string $attrs Comma-separated list of attribute names whose data must be included in the response. The attributes are retrieved in the order specified by this parameter. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. If this parameter is not included, the attributes are retrieved in arbitrary order, and all the attributes of the entity are included in the response. (optional)
     * @param  string $metadata A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)
     * @param  string $options Options dictionary (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function retrieveEntityRequest($entity_id, $type = null, $attrs = null, $metadata = null, $options = null)
    {
        // verify the required parameter 'entity_id' is set
        if ($entity_id === null || (is_array($entity_id) && count($entity_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entity_id when calling retrieveEntity'
            );
        }

        $resourcePath = '/v2/entities/{entityId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($attrs !== null) {
            $queryParams['attrs'] = ObjectSerializer::toQueryValue($attrs);
        }
        // query params
        if ($metadata !== null) {
            $queryParams['metadata'] = ObjectSerializer::toQueryValue($metadata);
        }
        // query params
        if ($options !== null) {
            $queryParams['options'] = ObjectSerializer::toQueryValue($options);
        }

        // path params
        if ($entity_id !== null) {
            $resourcePath = str_replace(
                '{' . 'entityId' . '}',
                ObjectSerializer::toPathValue($entity_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
//            $headers,
//            $httpBody
        );
    }

    /**
     * Operation retrieveEntityAttributes
     *
     * Retrieve Entity Attributes
     *
     * @param  string $entity_id Id of the entity to be retrieved (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     * @param  string $attrs Comma-separated list of attribute names whose data are to be included in the response. The attributes are retrieved in the order specified by this parameter. If this parameter is not included, the attributes are retrieved in arbitrary order, and all the attributes of the entity are included in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)
     * @param  string $metadata A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)
     * @param  string $options Options dictionary (optional)
     *
     * @throws \Dounasth\Ngsiv2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Dounasth\Ngsiv2\Model\RetrieveEntityAttributesResponse
     */
    public function retrieveEntityAttributes($entity_id, $type = null, $attrs = null, $metadata = null, $options = null)
    {
        list($response) = $this->retrieveEntityAttributesWithHttpInfo($entity_id, $type, $attrs, $metadata, $options);
        return $response;
    }

    /**
     * Operation retrieveEntityAttributesWithHttpInfo
     *
     * Retrieve Entity Attributes
     *
     * @param  string $entity_id Id of the entity to be retrieved (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     * @param  string $attrs Comma-separated list of attribute names whose data are to be included in the response. The attributes are retrieved in the order specified by this parameter. If this parameter is not included, the attributes are retrieved in arbitrary order, and all the attributes of the entity are included in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)
     * @param  string $metadata A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)
     * @param  string $options Options dictionary (optional)
     *
     * @throws \Dounasth\Ngsiv2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Dounasth\Ngsiv2\Model\RetrieveEntityAttributesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function retrieveEntityAttributesWithHttpInfo($entity_id, $type = null, $attrs = null, $metadata = null, $options = null)
    {
        $returnType = '\Dounasth\Ngsiv2\Model\RetrieveEntityAttributesResponse';
        $request = $this->retrieveEntityAttributesRequest($entity_id, $type, $attrs, $metadata, $options);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Dounasth\Ngsiv2\Model\RetrieveEntityAttributesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation retrieveEntityAttributesAsync
     *
     * Retrieve Entity Attributes
     *
     * @param  string $entity_id Id of the entity to be retrieved (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     * @param  string $attrs Comma-separated list of attribute names whose data are to be included in the response. The attributes are retrieved in the order specified by this parameter. If this parameter is not included, the attributes are retrieved in arbitrary order, and all the attributes of the entity are included in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)
     * @param  string $metadata A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)
     * @param  string $options Options dictionary (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retrieveEntityAttributesAsync($entity_id, $type = null, $attrs = null, $metadata = null, $options = null)
    {
        return $this->retrieveEntityAttributesAsyncWithHttpInfo($entity_id, $type, $attrs, $metadata, $options)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation retrieveEntityAttributesAsyncWithHttpInfo
     *
     * Retrieve Entity Attributes
     *
     * @param  string $entity_id Id of the entity to be retrieved (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     * @param  string $attrs Comma-separated list of attribute names whose data are to be included in the response. The attributes are retrieved in the order specified by this parameter. If this parameter is not included, the attributes are retrieved in arbitrary order, and all the attributes of the entity are included in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)
     * @param  string $metadata A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)
     * @param  string $options Options dictionary (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retrieveEntityAttributesAsyncWithHttpInfo($entity_id, $type = null, $attrs = null, $metadata = null, $options = null)
    {
        $returnType = '\Dounasth\Ngsiv2\Model\RetrieveEntityAttributesResponse';
        $request = $this->retrieveEntityAttributesRequest($entity_id, $type, $attrs, $metadata, $options);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'retrieveEntityAttributes'
     *
     * @param  string $entity_id Id of the entity to be retrieved (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     * @param  string $attrs Comma-separated list of attribute names whose data are to be included in the response. The attributes are retrieved in the order specified by this parameter. If this parameter is not included, the attributes are retrieved in arbitrary order, and all the attributes of the entity are included in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)
     * @param  string $metadata A list of metadata names to include in the response. See \&quot;Filtering out attributes and metadata\&quot; section for more detail. (optional)
     * @param  string $options Options dictionary (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function retrieveEntityAttributesRequest($entity_id, $type = null, $attrs = null, $metadata = null, $options = null)
    {
        // verify the required parameter 'entity_id' is set
        if ($entity_id === null || (is_array($entity_id) && count($entity_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entity_id when calling retrieveEntityAttributes'
            );
        }

        $resourcePath = '/v2/entities/{entityId}/attrs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($attrs !== null) {
            $queryParams['attrs'] = ObjectSerializer::toQueryValue($attrs);
        }
        // query params
        if ($metadata !== null) {
            $queryParams['metadata'] = ObjectSerializer::toQueryValue($metadata);
        }
        // query params
        if ($options !== null) {
            $queryParams['options'] = ObjectSerializer::toQueryValue($options);
        }

        // path params
        if ($entity_id !== null) {
            $resourcePath = str_replace(
                '{' . 'entityId' . '}',
                ObjectSerializer::toPathValue($entity_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
//            $headers,
//            $httpBody
        );
    }

    /**
     * Operation updateExistingEntityAttributes
     *
     * Update Existing Entity Attributes
     *
     * @param  string $entity_id Id of the entity to be updated (required)
     * @param  string $content_type  (required)
     * @param  \Dounasth\Ngsiv2\Model\UpdateExistingEntityAttributesRequest $body  (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     * @param  string $options Operations options (optional)
     *
     * @throws \Dounasth\Ngsiv2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateExistingEntityAttributes($entity_id, $content_type, $body, $type = null, $options = null)
    {
        $this->updateExistingEntityAttributesWithHttpInfo($entity_id, $content_type, $body, $type, $options);
    }

    /**
     * Operation updateExistingEntityAttributesWithHttpInfo
     *
     * Update Existing Entity Attributes
     *
     * @param  string $entity_id Id of the entity to be updated (required)
     * @param  string $content_type  (required)
     * @param  \Dounasth\Ngsiv2\Model\UpdateExistingEntityAttributesRequest $body  (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     * @param  string $options Operations options (optional)
     *
     * @throws \Dounasth\Ngsiv2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateExistingEntityAttributesWithHttpInfo($entity_id, $content_type, $body, $type = null, $options = null)
    {
        $returnType = '';
        $request = $this->updateExistingEntityAttributesRequest($entity_id, $content_type, $body, $type, $options);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updateExistingEntityAttributesAsync
     *
     * Update Existing Entity Attributes
     *
     * @param  string $entity_id Id of the entity to be updated (required)
     * @param  string $content_type  (required)
     * @param  \Dounasth\Ngsiv2\Model\UpdateExistingEntityAttributesRequest $body  (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     * @param  string $options Operations options (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateExistingEntityAttributesAsync($entity_id, $content_type, $body, $type = null, $options = null)
    {
        return $this->updateExistingEntityAttributesAsyncWithHttpInfo($entity_id, $content_type, $body, $type, $options)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateExistingEntityAttributesAsyncWithHttpInfo
     *
     * Update Existing Entity Attributes
     *
     * @param  string $entity_id Id of the entity to be updated (required)
     * @param  string $content_type  (required)
     * @param  \Dounasth\Ngsiv2\Model\UpdateExistingEntityAttributesRequest $body  (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     * @param  string $options Operations options (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateExistingEntityAttributesAsyncWithHttpInfo($entity_id, $content_type, $body, $type = null, $options = null)
    {
        $returnType = '';
        $request = $this->updateExistingEntityAttributesRequest($entity_id, $content_type, $body, $type, $options);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateExistingEntityAttributes'
     *
     * @param  string $entity_id Id of the entity to be updated (required)
     * @param  string $content_type  (required)
     * @param  \Dounasth\Ngsiv2\Model\UpdateExistingEntityAttributesRequest $body  (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     * @param  string $options Operations options (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateExistingEntityAttributesRequest($entity_id, $content_type, $body, $type = null, $options = null)
    {
        // verify the required parameter 'entity_id' is set
        if ($entity_id === null || (is_array($entity_id) && count($entity_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entity_id when calling updateExistingEntityAttributes'
            );
        }
        // verify the required parameter 'content_type' is set
        if ($content_type === null || (is_array($content_type) && count($content_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content_type when calling updateExistingEntityAttributes'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateExistingEntityAttributes'
            );
        }

        $resourcePath = '/v2/entities/{entityId}/attrs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($options !== null) {
            $queryParams['options'] = ObjectSerializer::toQueryValue($options);
        }
        // header params
        if ($content_type !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($content_type);
        }

        // path params
        if ($entity_id !== null) {
            $resourcePath = str_replace(
                '{' . 'entityId' . '}',
                ObjectSerializer::toPathValue($entity_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'PATCH',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateOrAppendEntityAttributes
     *
     * Update or Append Entity Attributes
     *
     * @param  string $entity_id Entity id to be updated (required)
     * @param  string $content_type  (required)
     * @param  \Dounasth\Ngsiv2\Model\UpdateOrAppendEntityAttributesRequest $body  (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     * @param  string $options Operations options (optional)
     *
     * @throws \Dounasth\Ngsiv2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateOrAppendEntityAttributes($entity_id, $content_type, $body, $type = null, $options = null)
    {
        $this->updateOrAppendEntityAttributesWithHttpInfo($entity_id, $content_type, $body, $type, $options);
    }

    /**
     * Operation updateOrAppendEntityAttributesWithHttpInfo
     *
     * Update or Append Entity Attributes
     *
     * @param  string $entity_id Entity id to be updated (required)
     * @param  string $content_type  (required)
     * @param  \Dounasth\Ngsiv2\Model\UpdateOrAppendEntityAttributesRequest $body  (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     * @param  string $options Operations options (optional)
     *
     * @throws \Dounasth\Ngsiv2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateOrAppendEntityAttributesWithHttpInfo($entity_id, $content_type, $body, $type = null, $options = null)
    {
        $returnType = '';
        $request = $this->updateOrAppendEntityAttributesRequest($entity_id, $content_type, $body, $type, $options);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updateOrAppendEntityAttributesAsync
     *
     * Update or Append Entity Attributes
     *
     * @param  string $entity_id Entity id to be updated (required)
     * @param  string $content_type  (required)
     * @param  \Dounasth\Ngsiv2\Model\UpdateOrAppendEntityAttributesRequest $body  (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     * @param  string $options Operations options (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateOrAppendEntityAttributesAsync($entity_id, $content_type, $body, $type = null, $options = null)
    {
        return $this->updateOrAppendEntityAttributesAsyncWithHttpInfo($entity_id, $content_type, $body, $type, $options)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateOrAppendEntityAttributesAsyncWithHttpInfo
     *
     * Update or Append Entity Attributes
     *
     * @param  string $entity_id Entity id to be updated (required)
     * @param  string $content_type  (required)
     * @param  \Dounasth\Ngsiv2\Model\UpdateOrAppendEntityAttributesRequest $body  (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     * @param  string $options Operations options (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateOrAppendEntityAttributesAsyncWithHttpInfo($entity_id, $content_type, $body, $type = null, $options = null)
    {
        $returnType = '';
        $request = $this->updateOrAppendEntityAttributesRequest($entity_id, $content_type, $body, $type, $options);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateOrAppendEntityAttributes'
     *
     * @param  string $entity_id Entity id to be updated (required)
     * @param  string $content_type  (required)
     * @param  \Dounasth\Ngsiv2\Model\UpdateOrAppendEntityAttributesRequest $body  (required)
     * @param  string $type Entity type, to avoid ambiguity in case there are several entities with the same entity id. (optional)
     * @param  string $options Operations options (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateOrAppendEntityAttributesRequest($entity_id, $content_type, $body, $type = null, $options = null)
    {
        // verify the required parameter 'entity_id' is set
        if ($entity_id === null || (is_array($entity_id) && count($entity_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entity_id when calling updateOrAppendEntityAttributes'
            );
        }
        // verify the required parameter 'content_type' is set
        if ($content_type === null || (is_array($content_type) && count($content_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content_type when calling updateOrAppendEntityAttributes'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling updateOrAppendEntityAttributes'
            );
        }

        $resourcePath = '/v2/entities/{entityId}/attrs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type);
        }
        // query params
        if ($options !== null) {
            $queryParams['options'] = ObjectSerializer::toQueryValue($options);
        }
        // header params
        if ($content_type !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($content_type);
        }

        // path params
        if ($entity_id !== null) {
            $resourcePath = str_replace(
                '{' . 'entityId' . '}',
                ObjectSerializer::toPathValue($entity_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;

            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
